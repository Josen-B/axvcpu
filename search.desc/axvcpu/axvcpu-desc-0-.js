searchState.loadedDescShard("axvcpu", 0, "This crate provides a simple virtual CPU abstraction for …\nTrait representing the per-CPU architecture-specific …\nA trait for architecture-specific vcpu.\nHost per-CPU states to run the guest.\nA virtual CPU with architecture-independent interface.\nThe result of <code>AxArchVCpu::run</code>. Can we reference or …\nThe interfaces which the underlying software (kernel or …\nThe mutable part of <code>AxVCpu</code>.\nThe vcpu is blocked.\nThe vcpu is powered off.\nTry to bring up a secondary CPU.\nThe configuration for creating a new <code>AxArchVCpu</code>. Used by …\nThe vcpu is created but not initialized yet.\nAn external interrupt happened.\nSomething bad happened during VM entry, the vcpu could not …\nThe vcpu is already initialized and can be bound to a …\nThe vcpu is halted.\nThe instruction executed by the vcpu performs a hypercall.\nAn invalid state.\nThe instruction executed by the vcpu performs a I/O read …\nThe instruction executed by the vcpu performs a I/O write …\nMemory management interfaces.\nThe instruction executed by the vcpu performs a MMIO read …\nThe instruction executed by the vcpu performs a MMIO write …\nA nested page fault happened. (EPT violation in x86)\nNothing special happened, the vcpu has handled the exit …\nThe vcpu is bound to a physical CPU and ready to run.\nThe vcpu is bound to a physical CPU and running.\nThe vcpu is trying to send an Inter-Processor Interrupt …\nThe configuration for setting up a created <code>AxArchVCpu</code>. …\nThe instruction executed by the vcpu performs a system …\nThe instruction executed by the vcpu performs a system …\nThe system should be powered off.\nThe state of a virtual CPU.\nReturn the architecture-specific per-CPU state. Panics if …\nReturn the mutable architecture-specific per-CPU state. …\nBind the vcpu to the current physical CPU.\nBind the vcpu to the current physical CPU.\nClear the current vcpu on the current physical CPU.\nGet the id of the physical CPU who has the priority to run …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the architecture-specific vcpu.\nGet the current vcpu on the current physical CPU.\nGet a mutable reference to the current vcpu on the current …\nDisable hardware virtualization on the current CPU.\nDisable hardware virtualization on the current CPU.\nEnable hardware virtualization on the current CPU.\nEnable hardware virtualization on the current CPU.\nGet the id of the vcpu.\nInitialize the per-CPU state.\nInject an interrupt to the vcpu.\nInject an interrupt to the vcpu.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFetches current interrupt (IRQ) number.\nFetches current interrupt (IRQ) number.\nDispatch an interrupt request (IRQ) to the underlying host …\nDispatch an interrupt request (IRQ) to the underlying host …\nGet whether the vcpu is the BSP. We always assume the …\nWhether hardware virtualization is enabled on the current …\nWhether the current CPU has hardware virtualization …\nExecute an operation on the architecture-specific vcpu, …\nCreate a new <code>AxArchVCpu</code>.\nCreate a new per-CPU state.\nCreate a new <code>AxVCpu</code>.\nCreate a new, uninitialized per-CPU state.\nGet the set of physical CPUs who can run this vcpu. If <code>None</code>…\nRun the vcpu until a vm-exit occurs.\nRun the vcpu.\nSet the current vcpu on the current physical CPU.\nSet the entry point of the vcpu.\nSets the entry address of the vcpu.\nSet the EPT root of the vcpu.\nSet the value of a general-purpose register according to …\nSets the value of a general-purpose register according to …\nSet return value of the vcpu.\nSets the return value of the vcpu.\nSet the state of the vcpu.\nSetup the vcpu.\nSetup the vcpu.\nGet the state of the vcpu.\nTransition the state of the vcpu. If the current state is …\nUnbind the vcpu from the current physical CPU.\nUnbind the vcpu from the current physical CPU.\nExecute a block with the current vcpu set to <code>&amp;self</code>.\nExecute a block with the state of the vcpu transitioned …\nCurrently unused. Maybe used for <code>PSCI_POWER_STATE</code> in the …\nThe access flags of the fault.\nThe physical address of the MMIO read.\nThe physical address of the MMIO write.\nThe address of the system register to be read.\nThe address of the system register to be written.\nThe guest physical address of the fault.\nThis argument passed as the first argument to the …\nThe arguments for the hypercall.\nThe data to be written.\nThe data to be written.\nRuntime-specified physical address of the secondary CPU’…\nArchitecture related VM entry failure reasons.\nThe hypercall number.\nThe port number of the I/O read.\nThe port number of the I/O write.\nThe index of reg to be read\nThe index of the GPR (general purpose register) where the …\nThe width of the reg to be read\nSpecifies whether the IPI should be sent to all CPUs …\nSpecifies whether the IPI should be sent to the current …\nSign-extend the read value if true.\nThe target vcpu id that is to be started.\nThe target CPU to send the IPI to. Invalid if any of …\nThe auxiliary field for the target CPU list. Used …\nData to be written.\nThe interrupt vector.\nThe IPI vector to be sent.\nThe width of the MMIO read.\nThe width of the MMIO write.\nThe width of the I/O read.\nThe width of the I/O write.")